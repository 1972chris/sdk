library #lib;
import self as self;
import "dart:core" as core;
import "dart:ffi" as ffi;
import "dart:typed_data" as typ;
import "dart:_internal" as _in;

import "dart:ffi";

@#C6
class Struct1 extends ffi::Struct {
  constructor #fromTypedDataBase([@vm.inferred-type.metadata=dart.typed_data::_Uint8List] core::Object #typedDataBase) → self::Struct1
    : super ffi::Struct::_fromTypedDataBase(#typedDataBase)
    ;
}
@#C6
class Struct2 extends ffi::Struct {
  constructor #fromTypedDataBase([@vm.inferred-type.metadata=dart.typed_data::_Uint8List] core::Object #typedDataBase) → self::Struct2
    : super ffi::Struct::_fromTypedDataBase(#typedDataBase)
    ;
}
@#C6
class Struct3 extends ffi::Struct {
  constructor #fromTypedDataBase([@vm.inferred-type.metadata=dart.typed_data::_Uint8List] core::Object #typedDataBase) → self::Struct3
    : super ffi::Struct::_fromTypedDataBase(#typedDataBase)
    ;
}
@#C6
abstract class Struct5 extends ffi::Struct {
}
@#C6
abstract class Struct6 extends ffi::Struct {
}
@#C6
abstract class Struct7 extends ffi::Struct {
}
@#C10
class Struct11 extends ffi::Struct {
  constructor #fromTypedDataBase([@vm.inferred-type.metadata=dart.ffi::Pointer] core::Object #typedDataBase) → self::Struct11
    : super ffi::Struct::_fromTypedDataBase(#typedDataBase)
    ;
[@vm.procedure-attributes.metadata=methodOrSetterCalledDynamically:false,getterCalledDynamically:false,hasThisUses:false,hasNonThisUses:false,hasTearOffUses:false,getterSelectorId:1]  get nested() → self::Struct12*
    return new self::Struct12::#fromTypedDataBase( block {
      core::Object #typedDataBase = [@vm.direct-call.metadata=dart.ffi::Struct._typedDataBase] this.{ffi::Struct::_typedDataBase};
      core::int #offset = (#C12).{core::List::[]}(ffi::_abi());
    } =>#typedDataBase is ffi::Pointer<dynamic> ?{core::Object} [@vm.inferred-type.metadata=dart.ffi::Pointer?] ffi::_fromAddress<self::Struct12*>([@vm.direct-call.metadata=dart.core::_IntegerImplementation.+??] [@vm.inferred-type.metadata=int (skip check)] [@vm.direct-call.metadata=dart.ffi::Pointer.address] [@vm.inferred-type.metadata=int?] #typedDataBase.{ffi::Pointer::address}.{core::num::+}(#offset)) : let typ::TypedData #typedData = _in::unsafeCast<typ::TypedData>(#typedDataBase) in [@vm.direct-call.metadata=dart.typed_data::_ByteBuffer.asUint8List] [@vm.inferred-type.metadata=dart.typed_data::_Uint8ArrayView (skip check)] [@vm.inferred-type.metadata=dart.typed_data::_ByteBuffer] #typedData.{typ::TypedData::buffer}.{typ::ByteBuffer::asUint8List}([@vm.direct-call.metadata=dart.core::_IntegerImplementation.+] [@vm.inferred-type.metadata=int (skip check)] [@vm.inferred-type.metadata=dart.core::_Smi] #typedData.{typ::TypedData::offsetInBytes}.{core::num::+}(#offset), (#C15).{core::List::[]}(ffi::_abi())));
}
@#C6
class Struct12 extends ffi::Struct {
  constructor #fromTypedDataBase(core::Object #typedDataBase) → self::Struct12
    : super ffi::Struct::_fromTypedDataBase(#typedDataBase)
    ;
}
[@vm.inferred-type.metadata=dart.ffi::Pointer?]static final field ffi::Pointer<ffi::NativeFunction<(self::Struct3*) →* ffi::Int32*>*>* _#ffiCallback0 = [@vm.inferred-type.metadata=dart.ffi::Pointer?] ffi::_pointerFromFunction<ffi::NativeFunction<(self::Struct3*) →* ffi::Int32*>*>(ffi::_nativeCallbackFunction<(self::Struct3*) →* ffi::Int32*>(#C16, 0));
[@vm.inferred-type.metadata=dart.ffi::Pointer?]static final field ffi::Pointer<ffi::NativeFunction<() →* self::Struct7*>*>* _#ffiCallback1 = [@vm.inferred-type.metadata=dart.ffi::Pointer?] ffi::_pointerFromFunction<ffi::NativeFunction<() →* self::Struct7*>*>(ffi::_nativeCallbackFunction<() →* self::Struct7*>(#C17, null));
static method main() → void {
  self::testLookupFunctionReturn();
  self::testLookupFunctionArgument();
  self::testAsFunctionReturn();
  self::testAsFunctionArgument();
  self::testFromFunctionArgument();
  self::testFromFunctionReturn();
  self::testPointerLoad();
  self::testNestedLoad();
}
static method testLookupFunctionReturn() → void {
  final ffi::DynamicLibrary* dylib = [@vm.inferred-type.metadata=dart.ffi::DynamicLibrary?] ffi::DynamicLibrary::executable();
  final () →* self::Struct1* function1 = let final self::Struct1 #t1 = new self::Struct1::#fromTypedDataBase([@vm.inferred-type.metadata=dart.typed_data::_Uint8List] typ::Uint8List::•(#C18)) in ffi::_asFunctionInternal<() →* self::Struct1*, () →* self::Struct1*>([@vm.direct-call.metadata=dart.ffi::DynamicLibrary.lookup??] [@vm.inferred-type.metadata=dart.ffi::Pointer? (skip check)] dylib.{ffi::DynamicLibrary::lookup}<ffi::NativeFunction<() →* self::Struct1*>*>("function1"));
  final self::Struct1* struct1 = [@vm.call-site-attributes.metadata=receiverType:#lib::Struct1* Function()*] function1.call();
  core::print(struct1);
}
static method testAsFunctionReturn() → void {
  final ffi::Pointer<ffi::NativeFunction<() →* self::Struct2*>*>* pointer = [@vm.inferred-type.metadata=dart.ffi::Pointer?] ffi::Pointer::fromAddress<ffi::NativeFunction<() →* self::Struct2*>*>(3735928559);
  final () →* self::Struct2* function2 = let final self::Struct2 #t2 = new self::Struct2::#fromTypedDataBase([@vm.inferred-type.metadata=dart.typed_data::_Uint8List] typ::Uint8List::•(#C18)) in ffi::_asFunctionInternal<() →* self::Struct2*, () →* self::Struct2*>(pointer);
  final self::Struct2* struct2 = [@vm.call-site-attributes.metadata=receiverType:#lib::Struct2* Function()*] function2.call();
  core::print(struct2);
}
[@vm.unboxing-info.metadata=(b)->i]static method useStruct3(self::Struct3* struct3) → core::int* {
  return 42;
}
static method testFromFunctionArgument() → void {
  final ffi::Pointer<ffi::NativeFunction<(self::Struct3*) →* ffi::Int32*>*>* pointer = let final self::Struct3 #t3 = new self::Struct3::#fromTypedDataBase([@vm.inferred-type.metadata=dart.typed_data::_Uint8List] typ::Uint8List::•(#C18)) in [@vm.inferred-type.metadata=dart.ffi::Pointer?] self::_#ffiCallback0;
  core::print(pointer);
}
static method testLookupFunctionArgument() → void {
  final ffi::DynamicLibrary* dylib = [@vm.inferred-type.metadata=dart.ffi::DynamicLibrary?] ffi::DynamicLibrary::executable();
  final (self::Struct5*) →* void function5 = [@vm.inferred-type.metadata=dart.core::_Closure?] ffi::_asFunctionInternal<(self::Struct5*) →* void, (self::Struct5*) →* ffi::Void*>([@vm.direct-call.metadata=dart.ffi::DynamicLibrary.lookup??] [@vm.inferred-type.metadata=dart.ffi::Pointer? (skip check)] dylib.{ffi::DynamicLibrary::lookup}<ffi::NativeFunction<(self::Struct5*) →* ffi::Void*>*>("function5"));
  core::print(function5);
}
static method testAsFunctionArgument() → void {
  final ffi::Pointer<ffi::NativeFunction<(self::Struct6*) →* ffi::Void*>*>* pointer = [@vm.inferred-type.metadata=dart.ffi::Pointer?] ffi::Pointer::fromAddress<ffi::NativeFunction<(self::Struct6*) →* ffi::Void*>*>(3735928559);
  final (self::Struct6*) →* void function6 = [@vm.inferred-type.metadata=dart.core::_Closure?] ffi::_asFunctionInternal<(self::Struct6*) →* void, (self::Struct6*) →* ffi::Void*>(pointer);
  core::print(function6);
}
static method returnStruct7() → self::Struct7* {
  throw "I don't want to create a Struct7!";
}
static method testFromFunctionReturn() → void {
  final ffi::Pointer<ffi::NativeFunction<() →* self::Struct7*>*>* pointer = [@vm.inferred-type.metadata=dart.ffi::Pointer?] self::_#ffiCallback1;
  core::print(pointer);
}
static method testPointerLoad() → void {
  final ffi::Pointer<self::Struct11*>* pointer = [@vm.inferred-type.metadata=dart.ffi::Pointer?] ffi::Pointer::fromAddress<self::Struct11*>(3735928559);
  final self::Struct11* struct11 = new self::Struct11::#fromTypedDataBase(pointer!);
  core::print(struct11);
}
static method testNestedLoad() → void {
  final ffi::Pointer<self::Struct11*>* pointer = [@vm.inferred-type.metadata=dart.ffi::Pointer?] ffi::Pointer::fromAddress<self::Struct11*>(3735928559);
  final self::Struct11* struct11 = new self::Struct11::#fromTypedDataBase(pointer!);
  final self::Struct12* struct12 = [@vm.direct-call.metadata=#lib::Struct11.nested] [@vm.inferred-type.metadata=#lib::Struct12] struct11.{self::Struct11::nested};
  core::print(struct12);
}
