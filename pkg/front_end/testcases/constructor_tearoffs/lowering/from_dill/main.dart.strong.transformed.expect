library /*isNonNullableByDefault*/;
//
// Problems in library:
//
// pkg/front_end/testcases/constructor_tearoffs/lowering/from_dill/main.dart:34:8: Error: Too few positional arguments: 1 required, 0 given.
//     f3a(); // error
//        ^
//
// pkg/front_end/testcases/constructor_tearoffs/lowering/from_dill/main.dart:35:8: Error: Too many positional arguments: 1 allowed, but 2 found.
// Try removing the extra positional arguments.
//     f3a(42, 87); // error
//        ^
//
// pkg/front_end/testcases/constructor_tearoffs/lowering/from_dill/main.dart:52:8: Error: Expected 1 type arguments.
//     f4a<int, String>(); // error
//        ^
//
// pkg/front_end/testcases/constructor_tearoffs/lowering/from_dill/main.dart:60:8: Error: Expected 0 type arguments.
//     f4b<int>(); // error
//        ^
//
// pkg/front_end/testcases/constructor_tearoffs/lowering/from_dill/main.dart:77:8: Error: Type argument 'String' doesn't conform to the bound 'num' of the type variable 'T' on 'call'.
// Try changing type arguments so that they conform to the bounds.
//     f5a<String>(); // error
//        ^
//
// pkg/front_end/testcases/constructor_tearoffs/lowering/from_dill/main.dart:78:8: Error: Expected 1 type arguments.
//     f5a<int, String>(); // error
//        ^
//
import self as self;
import "main_lib.dart" as mai;
import "dart:core" as core;

import "org-dartlang-testcase:///main_lib.dart";

static final field core::bool inSoundMode = !(core::_GrowableList::•<core::int?>(0) is{ForNonNullableByDefault} core::List<core::int>);
static method main() → dynamic {
  () → mai::Class1 f1a = #C1;
  mai::Class1 c1a = f1a(){() → mai::Class1};
  self::expect(true, c1a is{ForNonNullableByDefault} mai::Class1);
  dynamic f1b = #C1;
  dynamic c1b = f1b{dynamic}.call();
  self::expect(true, c1b is{ForNonNullableByDefault} mai::Class1);
  self::expect(true, core::identical(f1a, f1b));
  () → mai::Class2 f2a = #C2;
  mai::Class2 c2a = f2a(){() → mai::Class2};
  self::expect(true, c2a is{ForNonNullableByDefault} mai::Class2);
  dynamic f2b = #C2;
  dynamic c2b = f2b{dynamic}.call();
  self::expect(true, c2b is{ForNonNullableByDefault} mai::Class2);
  self::expect(true, core::identical(f2a, f2b));
  (core::int) → mai::Class3 f3a = #C3;
  mai::Class3 c3a = f3a(42){(core::int) → mai::Class3};
  self::expect(42, c3a.{mai::Class3::field}{core::int});
  () → Null {
    let final Never #t1 = invalid-expression "pkg/front_end/testcases/constructor_tearoffs/lowering/from_dill/main.dart:34:8: Error: Too few positional arguments: 1 required, 0 given.
    f3a(); // error
       ^" in f3a{<inapplicable>}.();
    let final Never #t2 = invalid-expression "pkg/front_end/testcases/constructor_tearoffs/lowering/from_dill/main.dart:35:8: Error: Too many positional arguments: 1 allowed, but 2 found.
Try removing the extra positional arguments.
    f3a(42, 87); // error
       ^" in f3a{<inapplicable>}.(42, 87);
  };
  dynamic f3b = #C3;
  dynamic c3b = f3b{dynamic}.call(87);
  self::expect(87, c3b{dynamic}.field);
  self::throws(() → dynamic => f3b{dynamic}.call());
  self::throws(() → dynamic => f3b{dynamic}.call(42, 87));
  <T extends core::Object? = dynamic>() → mai::Class4<T%> f4a = #C4;
  mai::Class4<dynamic> c4a = f4a<dynamic>(){() → mai::Class4<dynamic>};
  self::expect(true, c4a is{ForNonNullableByDefault} mai::Class4<dynamic>);
  self::expect(false, c4a is{ForNonNullableByDefault} mai::Class4<core::int>);
  mai::Class4<core::int> c4b = f4a<core::int>(){() → mai::Class4<core::int>};
  self::expect(true, c4b is{ForNonNullableByDefault} mai::Class4<core::int>);
  self::expect(false, c4b is{ForNonNullableByDefault} mai::Class4<core::String>);
  () → Null {
    let final Never #t3 = invalid-expression "pkg/front_end/testcases/constructor_tearoffs/lowering/from_dill/main.dart:52:8: Error: Expected 1 type arguments.
    f4a<int, String>(); // error
       ^" in f4a{<inapplicable>}.<core::int, core::String>();
  };
  () → mai::Class4<core::int> f4b = f4a<core::int>;
  mai::Class4<core::int> c4c = f4b(){() → mai::Class4<core::int>};
  self::expect(true, c4c is{ForNonNullableByDefault} mai::Class4<core::int>);
  self::expect(false, c4c is{ForNonNullableByDefault} mai::Class4<core::String>);
  () → Null {
    let final Never #t4 = invalid-expression "pkg/front_end/testcases/constructor_tearoffs/lowering/from_dill/main.dart:60:8: Error: Expected 0 type arguments.
    f4b<int>(); // error
       ^" in f4b{<inapplicable>}.<core::int>();
  };
  dynamic f4c = #C4;
  dynamic c4d = f4c{dynamic}.call();
  self::expect(true, c4d is{ForNonNullableByDefault} mai::Class4<dynamic>);
  self::expect(false, c4d is{ForNonNullableByDefault} mai::Class4<core::int>);
  self::throws(() → dynamic => f4c{dynamic}.call<core::int, core::String>());
  <T extends core::num>() → mai::Class5<T> f5a = #C5;
  mai::Class5<core::num> c5a = f5a<core::num>(){() → mai::Class5<core::num>};
  self::expect(true, c5a is{ForNonNullableByDefault} mai::Class5<core::num>);
  self::expect(false, c5a is{ForNonNullableByDefault} mai::Class5<core::int>);
  mai::Class5<core::int> c5b = f5a<core::int>(){() → mai::Class5<core::int>};
  self::expect(true, c5b is{ForNonNullableByDefault} mai::Class5<core::int>);
  self::expect(false, c5b is{ForNonNullableByDefault} mai::Class5<core::double>);
  () → Null {
    f5a<core::String>(){() → mai::Class5<core::String>};
    let final Never #t5 = invalid-expression "pkg/front_end/testcases/constructor_tearoffs/lowering/from_dill/main.dart:78:8: Error: Expected 1 type arguments.
    f5a<int, String>(); // error
       ^" in f5a{<inapplicable>}.<core::int, core::String>();
  };
  dynamic f5b = #C5;
  dynamic c5c = f5b{dynamic}.call();
  self::expect(true, c5c is{ForNonNullableByDefault} mai::Class5<core::num>);
  self::expect(false, c5c is{ForNonNullableByDefault} mai::Class5<core::int>);
  dynamic c5d = f5b{dynamic}.call<core::int>();
  self::expect(true, c5d is{ForNonNullableByDefault} mai::Class5<core::int>);
  self::expect(false, c5d is{ForNonNullableByDefault} mai::Class5<core::double>);
  self::throws(() → dynamic => f5b{dynamic}.call<core::String>());
  self::throws(() → dynamic => f5b{dynamic}.call<core::int, core::String>());
}
static method expect(dynamic expected, dynamic actual) → dynamic {
  if(!(expected =={core::Object::==}{(core::Object) → core::bool} actual))
    throw "Expected ${expected}, actual ${actual}";
}
static method throws(() → dynamic f, {core::bool inSoundModeOnly = #C6}) → dynamic {
  try {
    f(){() → dynamic};
  }
  on core::Object catch(final core::Object e) {
    core::print("Thrown: ${e}");
    return;
  }
  if(!self::inSoundMode && inSoundModeOnly) {
    return;
  }
  throw "Expected exception";
}

library /*isNonNullableByDefault*/;
import self as mai;
import "dart:core" as core;

class Class1 extends core::Object {
  synthetic constructor •() → mai::Class1
    : super core::Object::•()
    ;
  static method _#new#tearOff() → mai::Class1
    return new mai::Class1::•();
}
class Class2 extends core::Object {
  constructor named() → mai::Class2
    : super core::Object::•()
    ;
  static method _#named#tearOff() → mai::Class2
    return new mai::Class2::named();
}
class Class3 extends core::Object {
  final field core::int field;
  constructor •(core::int field) → mai::Class3
    : mai::Class3::field = field, super core::Object::•()
    ;
  static method _#new#tearOff(core::int field) → mai::Class3
    return new mai::Class3::•(field);
}
class Class4<T extends core::Object? = dynamic> extends core::Object {
  constructor _() → mai::Class4<mai::Class4::T%>
    : super core::Object::•()
    ;
  static method _#_#tearOff<T extends core::Object? = dynamic>() → mai::Class4<mai::Class4::_#_#tearOff::T%>
    return new mai::Class4::_<mai::Class4::_#_#tearOff::T%>();
  static factory •<T extends core::Object? = dynamic>() → mai::Class4<mai::Class4::•::T%>
    return new mai::Class4::_<mai::Class4::•::T%>();
  static method _#new#tearOff<T extends core::Object? = dynamic>() → mai::Class4<mai::Class4::_#new#tearOff::T%>
    return mai::Class4::•<mai::Class4::_#new#tearOff::T%>();
}
class Class5<T extends core::num> extends core::Object {
  constructor _() → mai::Class5<mai::Class5::T>
    : super core::Object::•()
    ;
  static method _#_#tearOff<T extends core::num>() → mai::Class5<mai::Class5::_#_#tearOff::T>
    return new mai::Class5::_<mai::Class5::_#_#tearOff::T>();
  static factory •<T extends core::num>() → mai::Class5<mai::Class5::•::T>
    return new mai::Class5::_<mai::Class5::•::T>();
  static method _#new#tearOff<T extends core::num>() → mai::Class5<mai::Class5::_#new#tearOff::T>
    return mai::Class5::•<mai::Class5::_#new#tearOff::T>();
}

constants  {
  #C1 = tearoff mai::Class1::_#new#tearOff
  #C2 = tearoff mai::Class2::_#named#tearOff
  #C3 = tearoff mai::Class3::_#new#tearOff
  #C4 = tearoff mai::Class4::_#new#tearOff
  #C5 = tearoff mai::Class5::_#new#tearOff
  #C6 = false
}
